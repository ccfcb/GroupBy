# -*- coding: utf-8 -*-
"""Helper_function_for_Flask.ipynb

Automatically generated by Colaboratory.

"""
import pandas as pd
import numpy as np
from tensorflow.keras.models import load_model
import boto3

client = boto3.client('s3')
path_df = 's3://elasticbeanstalk-us-west-2-681261969843/groupby_data/groupby_data_flask_final.csv'
df = pd.read_csv(path_df)
path_customer = 's3://elasticbeanstalk-us-west-2-681261969843/groupby_data/groupby_customer_data.csv'
customer_data = pd.read_csv(path_customer)
path_product = 's3://elasticbeanstalk-us-west-2-681261969843/groupby_data/groupby_product_data.csv'
product_data = pd.read_csv(path_product)

"""##Prediction of purchase conversion probability"""

def predict(customer):

  if customer in df['CustomerId'].values:
    # Predictions
    prediction = df['purchase_probability'].values

    # Compute average probability of purchase for the customers
    customer_predictions = df.groupby(['CustomerId'])['purchase_probability'].mean().reset_index(name='average_predictions')
    
    # Select prediction for the current customer
    customer_prob = customer_predictions['average_predictions'][customer_predictions['CustomerId']==customer].values.item()
    
    output = round(customer_prob, 2)  
    
  else:
    output = None
  
  return output

"""##Customer classification"""

def classify(customer):
  
  if customer in df['CustomerId'].values:
    classes = df['Class']
    for i in range(df.shape[0]):
      if df['CustomerId'][i] == customer:
        customer_class = df['Class'][i]
      continue
  else:
    customer_class = 'New Customer'
    
  return customer_class
  

"""##Recommendations"""

def recommend(customer):
  # Load model
  model = load_model('recommender')

  # Extract required data for recommendations
  data_rec = df[['CustomerId', 'ProductId', 'ProductName']]

  # Identify products previously purchased by customer
  if not customer in data_rec['CustomerId'].values:
    products_purchased = pd.DataFrame(data=[[customer, 'no_product', 'no_product']], 
                                      columns=['CustomerId', 'ProductId', 'ProductName'])
    customer_encoder = 0
    # customer_encoder = 0 is an actual customer. However, this is necessary here because the model does
    # not accept a new customer number. To ensure that all products are selected as 'not purchased',
    # use the products_purchased dataframe with 'no_product' entries as above.
  else:
    products_purchased = data_rec[data_rec.CustomerId == customer]
    customer_encoder = customer_data[customer_data['customer_id']==customer].iloc[:,1].item()

  # Search products not purchased by the customer to recommend
  products_not_purchased = data_rec[~data_rec['ProductId'].isin(products_purchased['ProductId'].values)]['ProductId']
  # Generate table of products not purchased by the customer
  products_not_purchased = list(set(products_not_purchased).intersection(set(product_data.iloc[:,0])))
  products_not_purchased = [[product_data.iloc[i,1]] for i in range(len(products_not_purchased))]
  customer_product_array = np.hstack(([[customer_encoder]] * len(products_not_purchased), products_not_purchased))

  # Predict products to recommend
  product_predict = model.predict(customer_product_array).flatten()

  # Select and decode top 3 recommendations
  top_product_indices = product_predict.argsort()[-3:][::-1]
  products_not_purchased = [[product_data.iloc[i,1]] for i in range(len(products_not_purchased))]

  # Find recommended product IDs and names
  recommended_product_ids = []
  recommended_products = []

  for i in top_product_indices:
    lookup_product_id = product_data.iloc[i,0]
    product_instance = data_rec[data_rec['ProductId'] == lookup_product_id].iloc[:,1:].drop_duplicates()
    lookup_product_name = product_instance.iloc[0,1]
    recommended_product_ids.append(lookup_product_id)
    recommended_products.append(lookup_product_name)

  # Convert product ids and names into dictionary and then dataframe
  recommendations = {recommended_product_ids[i]: recommended_products[i] for i in range(len(recommended_product_ids))}
  recommendations = pd.DataFrame(data=recommendations.items(), columns=['Product ID', 'Product Name'])

  return recommendations
